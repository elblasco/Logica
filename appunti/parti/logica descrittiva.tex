\documentclass[../main.tex]{subfiles}

\graphicspath{{\subfix{../img/}}}

\newcommand{\spazio}{\vspace{2em} \newline}

\begin{document}
   \part{Logica Descrittiva}

   \chapter{Logica}

   \section{Intuizioni}
   La FOL con la sua espressività permette di usare:
   \begin{itemize}
      \item costanti
      \item variabili libere
      \item simboli di funzioni
      \item \dots
   \end{itemize}
   Ma nella maggior parte delle applicazioni dell'informatica questa espressività non è richiesta.\\
   La grande espressività della FOL è motivita dal suo uso, ma si porta dietro dei costi di analisi molto elevati.\\
   Il linguaggio della FOL non ha struttura, risulta quindi appiattito, questo nonostante elementi diversi formalizzino intuizioni diverse.\\
   La FOL (e la PL) nella loro semantica hanno lo scopo di dare giudizi riguardanti dei fatti e quindi anche selle conseguenze sui fatti risultati veri.\\
   Per lo stesso motivo FOL e PL non forniscono alcuno strumento per ragionare sui fatti perchè codificati in formule atomiche, il predicato $P(t_1, \dots , t_n)$ viene usato solo per determinare quando lo stato è vero o falso.
   \begin{center}
      \begin{tabular}{c c c}
         $I \models t_1 = t_2[a]$ & iff & $I(t_1)[a] = I(t_2)[a]$\\
         $I \models P(t_1, \dots ,t_n)[a]$ & iff & $< I(t_1)[a], \dots, I(t_n)[a] > \in I(P) >$
      \end{tabular}
   \end{center}

   \subsection{Da FOL a logica descrittiva (DL)}
   \textbf{Espressività:} l'espressività è molto limitata perchè non abbiamo variabili libere, simboli di funzione e abbiamo solo predicati binari come simboli primitivi.
   \spazio
   \textbf{Decidibilità:} dobbiamo ridurre i domini in domini finiti e usare l'assunzione dei nomi univoci, lo standard sono le pratiche dei domini relazionali.
   \spazio
   \textbf{Mancanza di struttura:} per questa mancanza della FOL vengono esplicitate varie distinzioni:
   \begin{itemize}
      \item Come sono costrite le classi.
      \item Classi e ruoli (predicati unari vs binari).
      \item Schemi contro schemi popolati (TBox e ABox).
      \item Ragionamento schematico  (knowledge-level) contro ragionamento ground  (data-level).
   \end{itemize}
   \textbf{Scopo:} lo scopo della DL non è ragionare su cosa è vero ma ragionare sui fatti e sulle loro componenti.

   \section{Due logiche}
   \begin{itemize}
      \item \textbf{Conoscenze:} 
         \begin{itemize}
            \item Linguaggio naturale: informazioni e principi.
            \item Computer Science: il nome delle classi, il nome delle relazioni.
            \item Logica: predicati simbolici, qunatificatori universali e di esistenza.
         \end{itemize} 
      \item \textbf{Dati:}
         \begin{itemize}
            \item Linguaggio naturale: informazioni fattuali o calcolo.
            \item Computer Science: valori dei dati, enità e proprietà degli oggetti.
            \item Logic: costanti, termini ground e formule ground.
         \end{itemize}
   \end{itemize}
   L'usuale linguaggio è diviso in due insiemi ma collegati tra di loro:
   \begin{itemize}
      \item \textbf{TBox - la logica della conoscenza:} il linguaggio e la logica usati per specificare e ragionare sugli schemi usati per modellare i dati.\\
         Le TBox mappano direttamente in modelli Extended Entity-relationship (EER), relazioni dei DB e Knowledge Graphs (KG).
      \item \textbf{ABox - la logica dei dati:} il linguaggio e la logica usati per memorizzare e ragionare sui dati, si mappa sui dati contenuti nei DB e nei KG.
   \end{itemize}
   \textbf{T} significa \textbf{Terminologia} mentre \textbf{A} vuol dire \textbf{Asserzione}, sono collegati perchè le asserzioni fatte nelle ABox sfrutta la terminologia definita dalle TBox.\\
   In questo corso vedremmo la logica descrittiva $\mathcal{ALC}$, ovvero la DL la cui parte proposizionele corrisponde perfettamente alla PL.

   \section{Sintassi TBox}
   \textbf{Alfabeto:} un alfabeto è composto dai seguenti simboli:
   \begin{itemize}
      \item Simboli non logici: nomi di concetti (classi) quindi come persone, animali, cose \dots
      \item Simboli logici: 
         \begin{itemize}
            \item $\sqcap$ congiunzione, $\sqcup$ disgiunzione e $\lnot$ negazione di concetto.
            \item $\top$ dominio di interpretazione e $\perp$ insieme vuoto.
         \end{itemize}
   \end{itemize}
   \textbf{Conectto:} è un insieme di entità, la relazione formalizzata nei DB.

   Di seguito parleremo di concetto (interpretazione) intendendo il nome del concetto (linguaggio). 
   \spazio
   \textbf{Ruolo:} un lafabeto contiene i seguenti simboli:
   \begin{itemize}
      \item Simboli non logici: nomi di ruoli (relazioni) $R_1, R_2, \dots , R_n$.
      \item Simboli logici: $\forall$ e $\exists$.
   \end{itemize}

   \subsubsection{Esempio di ruoli}
   Consideriamo i seguenti concetti e nomi:
   \begin{itemize}
      \item Nomi concetti:Vehicle, Boat, Bicycle, Car, Device, Wheel, Engine, Axle, Rotation, Water, Human, Driver, Adult, Child.
      \item Nomi ruoli: hasPart, poweredBy, capableOf, travelsOn, controls.
   \end{itemize}
   Formalizziamo una serie di frasi in linguaggio naturale.
   \begin{enumerate}
      \item Those vehicles that have wheels and are powered by an engine.
      \item Those vehicles that have wheels and are powered by a human.
      \item Those vehicles that travel on water.
      \item Those objects which have no wheels.
      \item Those objects which do not travel on water.
      \item Those devices that have an axle and are capable of rotation.
      \item Those humans who control a vehicle.
      \item The drivers of cars.
   \end{enumerate}
   Le trasposizioni in DL sono:
   \begin{enumerate}
      \item Vehicle$\sqcap \exists$hasPart.Wheel$\sqcap \exists$poweredBy.Engine
      \item Vehicle$\sqcap \exists$hasPart.Wheel$\sqcap \exists$poweredBy.Human
      \item Vehivle$\sqcap \exists$travelsOn.Water
      \item $\forall$hasPart.$\lnot$Wheel
      \item $\forall$ travelsOn.$\lnot$Water
      \item Device$\sqcap \exists$hasPart.Axle$\sqcap \exists$capableOf.Rotation
      \item Human$\sqcap \exists$controls.Vehicle
      \item Driver$\sqcap \exists$controls.Car
   \end{enumerate}
   \vspace{2em}
   \textbf{Descrizione concettuale:} dato un insieme di nomi di concetti \textbf{C} e un insieme di nomi di ruoli \textbf{R}, l'insieme delle descrizioni dei concetti su \textbf{C} e \textbf{R} è definito come:
   \begin{itemize}
      \item Ogni nome di un concetto è una descrizione di concetto.
      \item $\top$ e $\bot$ sono descrizioni di concetti.
      \item Se C e D sono due concetti e $r$ il nome di un ruolo, allora le seguenti formule sono descrizioni di concetti:
      \begin{itemize}
         \item C $\sqcap$ D
         \item C $\sqcup$ D
         \item $\lnot$ C
         \item $\exists$ $r$.C
         \item $\forall$ $r$.C
      \end{itemize} 
   \end{itemize}
   La descrizione concettuale non esprime le relazioni in un DB ma le assunzioni che si fanno per fare il design di un DB.
   \spazio
   \textbf{Dominio di interpretazione:} un dominio di interpretazione in DL è un insieme i cui elementi sono chiamati individui o oggetti, nel seguente modo:
   \begin{itemize}
      \item Per ogni nome di concetto gli elementi appartenenti alla sua estensione sono parte del dominio.
      \item Per ogni nome di ruolo gli elementi (coppie ordinate di elementi) appartenenti alla sua estensione sono parte del dominio.
   \end{itemize}
   \vspace{2em}
   \textbf{Interpretazione TBox:} dato un insieme di nomi di concetti \textbf{C} e un insieme di nomi di ruoli \textbf{R}; dato un dominio $\Delta ^\prime$, un interpretazione $I=(\Delta^\prime, \cdot^\prime)$ è composta dal dominio con una funzione di mappatura che:
   \begin{itemize}
      \item Associa ogni nome di concetto C $\in$ \textbf{C} ad un insieme C$^\prime \subseteq \Delta^\prime$.
      \item Associa ogni nome di ruolo $r \in$\textbf{R} ad un insieme $r^\prime \subseteq \Delta^\prime \times \Delta^\prime$.
      \item Associa descrizioni di concetti composti nel seguente modo:
      \begin{itemize}
         \item $\top^\prime = \Delta^\prime$
         \item $\bot^\prime = \emptyset$
         \item $(C \sqcap D)^\prime = C^\prime \cap D^\prime$
         \item $(C \sqcup D)^\prime = C^\prime \cup D^\prime$
         \item $\lnot C^\prime = \Delta^\prime \backslash C^\prime$
         \item $(\exists r.C) = \{ d \in \Delta^\prime | \text{esiste una } e \in \Delta^\prime \text{con } (d,e) \in r^\prime \text{ e } e \in C^\prime\}$
         \item $(\forall r.C) = \{ d \in \Delta^\prime | \text{per tutte le } e \in \Delta^\prime \text{se } (d,e) \in r^\prime \text{ allora } e \in C^\prime\}$
      \end{itemize} 
   \end{itemize}

   \section{Teorie TBox}
   \textbf{Concetto di inclusione:} un concetto di inclusione è un'espressione della seguente forma:
   \begin{center}
      $C \sqsubseteq D$
   \end{center}
   dove C e D sono descrizioni di concetti. $C \sqsubseteq D$ va letto come "C è sussunta da D".

   \subsubsection{Esempio}
   Consideriamo i seguenti concetti e nomi:
   \begin{itemize}
      \item Nomi concetti:Vehicle, Boat, Bicycle, Car, Device, Wheel, Engine, Axle, Rotation, Water, Human, Driver, Adult, Child.
      \item Nomi ruoli: hasPart, poweredBy, capableOf, travelsOn, controls.
   \end{itemize}
   Formalizziamo una serie di frasi in linguaggio naturale.
   \begin{enumerate}
      \item Boats have no wheels.
      \item Cars and bicycles do not travel on water.
      \item Drivers of cars are adults.
      \item Humans are not vehicles.
      \item Wheels or engines are not humans.
      \item Humans are either adults or children.
      \item Adults are not children.
   \end{enumerate}
   Le trasposizioni in DL sono:
   \begin{enumerate}
      \item Boat$\sqsubseteq \forall$hasPart.$\lnot$Wheel
      \item Car$\sqcup$Bicycle$\sqsubseteq \forall$travelsOn.$\lnot$Water
      \item Driver$\sqcap \exists$controls.Car$\sqsubseteq$Adult
      \item Human$\sqsubseteq \lnot$Vehicle
      \item Wheel$\sqcup$Engine$\sqsubseteq \lnot$Human
      \item Human$\sqsubseteq$Adult$\sqcup$Child
      \item Adult$\sqsubseteq \lnot$Child
   \end{enumerate}
   \vspace{2em}
   \textbf{Soddisfabilità dell'inclusione dei concetti:} sia \textbf{C} un insieme di nomi di concetti e \textbf{R} un insieme di nomi di ruoli, allor adato un dominio $\Delta^\prime$ e un'interpretazione $I = (\Delta^\prime, \cdot^\prime)$ abbiamo che:
   \begin{center}
      se $C^\prime \subseteq D^\prime$ allora $I$ è un modello di $C \sqsubseteq D$
   \end{center}
   dove C e D sono descrizionali concettuali.
   \spazio
   \textbf{TBox:} una TBox è un insieme finito di inclusioni concettuali, come un insieme finito di espressioni $C \sqsubseteq D$, dove C e D sono nomi di concetti (che possibilmente coinvolgono concetti composti).
   
   \subsubsection{Esempio}
   Consideriamo la descrizione concettuale "Dogs are Computer Science professors", che in DL diventa Dog $\sqsubseteq$ CS\_Professor.\\
   Possiamo dimostrare l'insoddisfacibilità di questa frase con una TBox:
   \begin{equation*}
      \mathcal{T}=
      \begin{cases}
         CS\_Professor \sqsubseteq Professor\\
         Professor \sqsubseteq Person\\
         Person \sqsubseteq \lnot Dog
      \end{cases}
   \end{equation*}
   \spazio
   \textbf{Modello per TBox:} sia \textbf{C} un insieme di nomi di concetti e \textbf{R} un insieme di nomi di ruoli, dato $\Delta^\prime$ e la sua interpretazione $I = (\Delta^\prime, \cdot^\prime)$, C e D descrizioni concettuali allora se $C^\prime \subseteq D^\prime$ per ogni $C \sqsubseteq D \in \mathcal{T}$ vuol dire che $I$ è un moodello per $\mathcal{T}$.
   \spazio
   \textbf{Definizione di concetto:} una definizione di concetto è un'espressione della seguente forma:
   \begin{center}
      $C \equiv D$ se e solo se $C \sqsubseteq D$ e $D \sqsubseteq C$.
   \end{center}
   dove C e D sono descrizioni concettuali e $C \equiv D$ va letto come "C è equivalente a D".

   \subsubsection{Esempio}
   Consideriamo i seguenti concetti e nomi:
   \begin{itemize}
      \item Nomi concetti:Vehicle, Boat, Bicycle, Car, Device, Wheel, Engine, Axle, Rotation, Water, Human, Driver, Adult, Child.
      \item Nomi ruoli: hasPart, poweredBy, capableOf, travelsOn, controls.
   \end{itemize}
   Formalizziamo una serie di frasi in linguaggio naturale.
   \begin{enumerate}
      \item Cars are exactly those vehicles that have wheels and are powered by an engine
      \item Bicycles are exactly those vehicles that have wheels and are powered by a human
      \item Boats are exactly those vehicles that travel on water
      \item Wheels are exactly those devices that have an axle and are capable of rotation
      \item Drivers are exactly those humans who control a vehicle
   \end{enumerate}
   Le trasposizioni in DL sono:
   \begin{enumerate}
      \item Car$\equiv$Vehicle$\sqcap \exists$hasPart.Wheel$\sqcap \exists$poweredBy.Engine
      \item Bicyle$\equiv$ Vehicle$\sqcap \exists$hasPart.Wheel$\sqcap \exists$poweredBy.Human
      \item Boat$\equiv$ Vehicle$\sqcap \exists$travelsOn.Water
      \item Wheel$\equiv$Device$\sqcap \exists$hasPart.Axle$\sqcap \exists$capableOf.Rotation
      \item Driver$\equiv$Human$\sqcap \exists$controls.Vehicle
   \end{enumerate}
   \vspace{2em}
   \textbf{TBox definita:} una TBox è definita se soddiafa le seguenti proprietà:
   \begin{itemize}
      \item Ogni concetto può apparire al più una volta nel lato sinistro di una definizione.
      \item Sono presenti solo equivalenze concettuali $(C \equiv D)$.
      \item E' aciclica quindi non esistono definizioni del tipo $C \equiv C$.
   \end{itemize} 
   \subsubsection{Esempio}
   \begin{equation*}
      \mathcal{T}=
      \begin{cases}
         Person \equiv \exists hasname.String \sqcap \forall HasJob.Organization\\
         Woman \equiv Person \sqcap  Female\\
         Man \equiv Person \sqcap  \lnot Woman\\
         Mother \equiv Woman \sqcap  \exists hasChild.Person\\
         Father \equiv Man \sqcap  \exists hasChild.Person\\
         Parent \equiv Father \sqcup Mother
      \end{cases}
   \end{equation*}
   \vspace{2em}
   \textbf{Unfolding di concetti:} un concetto è unfolded se tutte le sue componenti hanno una definizioni.
   \spazio
   \textbf{TBox unfolding:} una TBox $\mathcal{T}$ può essere unfolded in una TBox $\mathcal{T}^\prime$ se tutti i suoi concetti sono unfolded.

   \section{Sintassi ABox}
   \textbf{Asserzione:} un asserzione è un espressione del tipo:
   \begin{itemize}
      \item C(a) asserzione di concetto
      \item r(a,b) asserzione di ruolo
   \end{itemize}
   dove a e b sono individui, C è un concetto (possibilmente composto) e r è il nome di un ruolo.
\end{document}